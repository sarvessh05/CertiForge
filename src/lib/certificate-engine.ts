import { PDFDocument, rgb } from "pdf-lib";
import * as fontkit from "fontkit";
import QRCode from "qrcode";
import JSZip from "jszip";
import { saveAs } from "file-saver";
import type { TextElement, SignatureElement } from "@/components/CertificateEditor";

interface GenerateOptions {
  templateFile: File;
  data: Record<string, string>[];
  mapping: Record<string, string>;
  elements: TextElement[];
  enableQR: boolean;
  qrPosition: { x: number; y: number };
  signatures: SignatureElement[];
  onProgress: (current: number) => void;
}

// Google Fonts CDN URLs for font files
const FONT_URLS: Record<string, string> = {
  // Elegant Serif
  "Playfair Display": "https://fonts.gstatic.com/s/playfairdisplay/v36/nuFvD-vYSZviVYUb_rj3ij__anPXJzDwcbmjWBN2PKdFvUDQZNLo_U2r.ttf",
  "Cinzel": "https://fonts.gstatic.com/s/cinzel/v23/8vIU7ww63mVu7gtR-kwKxNvkNOjw-tbnTYrvDE5ZdqU.ttf",
  "Cormorant Garamond": "https://fonts.gstatic.com/s/cormorantgaramond/v16/co3PMX5slCNuHLi8bLeY9MK7whWMhyjQAllvuQWJ5heb_w.ttf",
  "Libre Baskerville": "https://fonts.gstatic.com/s/librebaskerville/v14/kmKiZrc3Hgbbcjq75U4uslyuy4kn0qNcWx8QDO-WzQ.ttf",
  "Merriweather": "https://fonts.gstatic.com/s/merriweather/v30/u-4n0qyriQwlOrhSvowK_l521wRZWMf6hPvhPUWH.ttf",
  "EB Garamond": "https://fonts.gstatic.com/s/ebgaramond/v27/SlGDmQSNjdsmc35JDF1K5E55YMjF_7DPuGi-6_RUA4V-e6yHgQ.ttf",
  "Crimson Text": "https://fonts.gstatic.com/s/crimsontext/v19/wlppgwHKFkZgtmSR3NB0oRJvaAJSA_JN3Q.ttf",
  "Old Standard TT": "https://fonts.gstatic.com/s/oldstandardtt/v18/MwQubh3o1vLImiwAVvYawgcf2eVurVC5RHdCZg.ttf",
  
  // Modern Sans
  "Montserrat": "https://fonts.gstatic.com/s/montserrat/v26/JTUSjIg1_i6t8kCHKm459WdhyyTh89ZNpQ.ttf",
  "Poppins": "https://fonts.gstatic.com/s/poppins/v21/pxiByp8kv8JHgFVrLEj6Z1JlFc-K.ttf",
  "Raleway": "https://fonts.gstatic.com/s/raleway/v34/1Ptxg8zYS_SKggPN4iEgvnHyvveLxVvaorCGPrcVIT9d0c-dYA.ttf",
  "Lato": "https://fonts.gstatic.com/s/lato/v24/S6u9w4BMUTPHh7USSwaPGR_p.ttf",
  "Oswald": "https://fonts.gstatic.com/s/oswald/v53/TK3_WkUHHAIjg75cFRf3bXL8LICs1_FvsUtiZTaR.ttf",
  "Roboto": "https://fonts.gstatic.com/s/roboto/v32/KFOmCnqEu92Fr1Me5WZLCzYlKw.ttf",
  "Open Sans": "https://fonts.gstatic.com/s/opensans/v40/memSYaGs126MiZpBA-UvWbX2vVnXBbObj2OVZyOOSr4dVJWUgsjZ0C4nY1M2xLER.ttf",
  
  // Script/Signature
  "Great Vibes": "https://fonts.gstatic.com/s/greatvibes/v19/RWmMoKWR9v4ksMfaWd_JN-XCg6UKDXlq.ttf",
  "Allura": "https://fonts.gstatic.com/s/allura/v21/9oRPNYsQpS4zjuAPjAIXPtrrGA.ttf",
  "Dancing Script": "https://fonts.gstatic.com/s/dancingscript/v25/If2cXTr6YS-zF4S-kcSWSVi_sxjsohD9F50Ruu7BMSoHTeB9ptDqpw.ttf",
  "Pacifico": "https://fonts.gstatic.com/s/pacifico/v22/FwZY7-Qmy14u9lezJ96A4sijpFu_.ttf",
  "Sacramento": "https://fonts.gstatic.com/s/sacramento/v15/buEzpo6gcdjy0EiZMBUG0CoV_NxLeiw.ttf",
};

// Cache for loaded fonts
const fontCache = new Map<string, ArrayBuffer>();

async function loadFont(fontFamily: string): Promise<ArrayBuffer | null> {
  // Check cache first
  if (fontCache.has(fontFamily)) {
    return fontCache.get(fontFamily)!;
  }

  const url = FONT_URLS[fontFamily];
  if (!url) return null;

  try {
    const response = await fetch(url);
    if (!response.ok) return null;
    const fontData = await response.arrayBuffer();
    fontCache.set(fontFamily, fontData);
    return fontData;
  } catch (error) {
    console.error(`Failed to load font ${fontFamily}:`, error);
    return null;
  }
}

export async function generateCertificates(options: GenerateOptions): Promise<Blob> {
  const {
    templateFile,
    data,
    mapping,
    elements,
    enableQR,
    qrPosition,
    signatures,
    onProgress,
  } = options;

  const zip = new JSZip();
  const templateBytes = await templateFile.arrayBuffer();
  const isImage = templateFile.type.startsWith("image/");

  // Pre-load all required fonts
  const uniqueFonts = [...new Set(elements.filter(el => el.enabled).map(el => el.fontFamily))];
  const fontPromises = uniqueFonts.map(font => loadFont(font));
  await Promise.all(fontPromises);

  // Pre-load signature images
  const signatureImages = new Map<string, ArrayBuffer>();
  for (const sig of signatures) {
    if (sig.enabled) {
      const sigBytes = await sig.file.arrayBuffer();
      signatureImages.set(sig.id, sigBytes);
    }
  }

  for (let i = 0; i < data.length; i++) {
    const row = data[i];

    let pdfDoc: PDFDocument;

    if (isImage) {
      pdfDoc = await PDFDocument.create();
      const img = templateFile.type.includes("png")
        ? await pdfDoc.embedPng(templateBytes)
        : await pdfDoc.embedJpg(templateBytes);
      const { width, height } = img.scale(1);
      const page = pdfDoc.addPage([width, height]);
      page.drawImage(img, { x: 0, y: 0, width, height });
    } else {
      pdfDoc = await PDFDocument.load(templateBytes);
    }

    // Register fontkit
    pdfDoc.registerFontkit(fontkit);

    // Set PDF metadata (invisible signature)
    pdfDoc.setTitle("Certificate generated by Veriforge");
    pdfDoc.setAuthor("Sarvesh Ghotekar");
    pdfDoc.setCreator("Veriforge by Sarvesh Ghotekar");
    pdfDoc.setProducer("Veriforge - Bulk Certificate Automation");
    pdfDoc.setSubject("Certificate of Achievement");
    pdfDoc.setKeywords(["certificate", "achievement", "veriforge", "sarvesh ghotekar"]);

    const page = pdfDoc.getPages()[0];
    const { width: pageW, height: pageH } = page.getSize();

    // Scale from 800px canvas to actual PDF dimensions
    const scaleX = pageW / 800;
    const scaleY = pageH / (800 * (pageH / pageW));

    for (const el of elements) {
      if (!el.enabled) continue;
      const columnName = mapping[el.key];
      if (!columnName) continue;
      const text = String(row[columnName] ?? "");
      if (!text) continue;

      // Try to load custom font, fallback to Helvetica
      let font;
      const fontData = await loadFont(el.fontFamily);
      
      if (fontData) {
        try {
          font = await pdfDoc.embedFont(fontData);
        } catch (error) {
          console.error(`Failed to embed font ${el.fontFamily}, using fallback`, error);
          // Fallback to Helvetica
          const { StandardFonts } = await import("pdf-lib");
          font = await pdfDoc.embedFont(StandardFonts.Helvetica);
        }
      } else {
        // Use standard font as fallback
        const { StandardFonts } = await import("pdf-lib");
        font = await pdfDoc.embedFont(StandardFonts.Helvetica);
      }

      const hexColor = el.color;
      const r = parseInt(hexColor.slice(1, 3), 16) / 255;
      const g = parseInt(hexColor.slice(3, 5), 16) / 255;
      const b = parseInt(hexColor.slice(5, 7), 16) / 255;

      const fontSize = el.fontSize * scaleX;
      const textWidth = font.widthOfTextAtSize(text, fontSize);

      page.drawText(text, {
        x: el.x * scaleX - textWidth / 2,
        y: pageH - el.y * scaleY,
        size: fontSize,
        font,
        color: rgb(r, g, b),
      });
    }

    // Add signatures
    for (const sig of signatures) {
      if (!sig.enabled) continue;
      const sigBytes = signatureImages.get(sig.id);
      if (!sigBytes) continue;

      try {
        const sigImage = sig.file.type.includes("png")
          ? await pdfDoc.embedPng(sigBytes)
          : await pdfDoc.embedJpg(sigBytes);

        const sigWidth = sig.width * scaleX;
        const sigHeight = sig.height * scaleX;

        page.drawImage(sigImage, {
          x: sig.x * scaleX - sigWidth / 2,
          y: pageH - sig.y * scaleY - sigHeight / 2,
          width: sigWidth,
          height: sigHeight,
        });
      } catch (error) {
        console.error(`Failed to embed signature ${sig.label}:`, error);
      }
    }

    // QR Code
    if (enableQR) {
      const certId = row[mapping["id"] || ""] || `CERT-${i + 1}`;
      const qrDataUrl = await QRCode.toDataURL(
        `https://verify.veriforge.app/cert/${certId}`,
        { width: 120, margin: 1 }
      );
      const qrImageBytes = Uint8Array.from(
        atob(qrDataUrl.split(",")[1]),
        (c) => c.charCodeAt(0)
      );
      const qrImage = await pdfDoc.embedPng(qrImageBytes);
      const qrSize = 60 * scaleX;
      page.drawImage(qrImage, {
        x: qrPosition.x * scaleX - qrSize / 2,
        y: pageH - qrPosition.y * scaleY - qrSize / 2,
        width: qrSize,
        height: qrSize,
      });
    }

    const pdfBytes = await pdfDoc.save();
    const name = row[mapping["name"] || ""] || `certificate_${i + 1}`;
    const safeName = name.replace(/[^a-zA-Z0-9_\- ]/g, "").trim();
    zip.file(`${safeName}.pdf`, pdfBytes);

    onProgress(i + 1);
  }

  return await zip.generateAsync({ type: "blob" });
}

export function downloadZip(blob: Blob, filename = "certificates.zip") {
  saveAs(blob, filename);
}
